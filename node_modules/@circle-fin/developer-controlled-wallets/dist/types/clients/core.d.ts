import * as _shared_clients_configurations from './configurations';
import { ConfigurationsClient, Blockchain, TokenMonitorScope, TestnetBlockchain } from './configurations';
import * as axios from 'axios';
import { AxiosResponse, AxiosError } from 'axios';

type TrimDataResponse<T extends {
    data?: unknown;
}> = Omit<AxiosResponse<T>, 'data'> & {
    data?: T['data'];
};
interface Storage<TStoredData extends object = object> {
    /**
     * Retrieves the value associated with a given key from the storage.
     * @param key - The key of the value to retrieve.
     * @returns A promise that resolves to the corresponding value, or undefined if not found.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets a value associated with a given key in the storage.
     * @param key - The key of the value to set.
     * @param value - The value to store.
     * @returns A promise that resolves when the operation is complete.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}
/**
 * Represents pagination options for querying items.
 */
interface Pagination {
    /**
     * Start time of the query, inclusive.
     */
    from?: string;
    /**
     * End time of the query, inclusive. Defaults to the current time.
     */
    to?: string;
    /**
     * Used to return items before the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageAfter`.
     */
    pageBefore?: string;
    /**
     * Used to return items after the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageBefore`.
     */
    pageAfter?: string;
    /**
     * The number of items to return.
     */
    pageSize?: number;
}
/**
 * Common interface for all API requests.
 */
type Common = {
    /**
     * Developer-provided parameter used to identify this request.
     */
    xRequestId?: string;
};
interface APIParams<TClient = unknown, TStoredData extends object = object> {
    /**
     * Storage solution for persisting data.
     */
    storage?: Storage<TStoredData>;
    /**
     * An instance of the Main Client. Ready to be used.
     */
    client: TClient;
    /**
     * An instance of the ConfigurationsClient. Ready to be used.
     */
    configurationsClient: ConfigurationsClient;
}
interface ClientParams<TStoredData extends object = object> {
    /**
     * Api Key that is used to authenticate against Circle APIs.
     */
    apiKey: string;
    /**
     * Optional base URL to override the default: `https://api.circle.com`.
     */
    baseUrl?: string;
    /**
     * Optional custom user agent request header. We will prepend it to default user agent header if provided.
     */
    userAgent?: string;
    /**
     * Optional custom storage solution for persisting data. We will fallback to InMemoryStorage if none was provided.
     */
    storage?: Storage<TStoredData>;
    /**
     * Additional headers that should be added to each request.
     */
    headers?: Record<string, string>;
}
type APIReturnType<T extends {
    data?: unknown;
}> = Promise<TrimDataResponse<T>>;
/**
 * Represents the configuration for setting fees.
 * It can be either FeeLevelInput, GasInput, or FeeInput.
 */
type FeeConfiguration<TFeeLevel> = {
    /**
     * Use absolute numbers to determine the fees that should be paid.
     */
    type: 'absolute';
    config: {
        /**
         * The maximum price per gas unit (see gasLimit), in gwei.
         * Requires priorityFee, and gasLimit, but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods to get this fee's estimates.
         */
        maxFee: string;
        /**
         * Requires maxFee, and gasLimit but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods for fee estimates.
         */
        priorityFee: string;
        /**
         * The maximum gas units for the transaction, required if feeLevel isn't provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
    };
} | {
    /**
     * Use gasLimit and gasPrice for fee determination.
     */
    type: 'gas';
    config: {
        /**
         * The maximum gas units for the transaction, required if feeLevel is not provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
        /**
         * For EIP-1559 supported blockchains, it's the max gas price per gas unit (see gasLimit), in gwei.
         * Requires gasLimit and incompatible with feeLevel, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee estimates.
         */
        gasPrice: string;
    };
} | {
    /**
     * Use the fee level to configure the fees that will be paid.
     */
    type: 'level';
    config: {
        /**
         * A dynamic fee level setting (LOW, MEDIUM, HIGH) determining the gas price for the transaction,
         * based on network conditions. Incompatible with gasPrice, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee level estimates.
         */
        feeLevel: TFeeLevel;
        /**
         * Optional gas limit override (only supported for EOA wallets).
         * When provided alongside feeLevel, the gasLimit must be greater than or equal to
         * the feeLevel estimation and will override the estimation's gasLimit.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit?: string;
    };
};
/**
 * Represents the input to delete a monitored token.
 */
type DeleteMonitoredTokensInput = {
    /**
     * Token ids to be removed from the monitored tokens list. Once removed, these tokens will no longer be shown by default when fetching wallet balances.
     */
    tokenIds: Array<string>;
};
/**
 * Represents the input to list all monitored tokens.
 */
type ListMonitoredTokensInput = {
    blockchain?: Blockchain;
    tokenAddress?: string;
    symbol?: string;
} & Pagination;
/**
 * Represents the input to create monitored tokens.
 */
interface CreateMonitoredTokensInput {
    /**
     * The list of tokens to add to the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     */
    tokenIds: Array<string>;
}
/**
 * Represents the input to update monitored tokens.
 */
interface UpdateMonitoredTokensInput {
    /**
     * The list of tokens that will be added to the monitored tokens list. When fetching wallet balances, these tokens will be shown by default.
     */
    tokenIds?: Array<string>;
}
/**
 * Represents the input select between monitoring all tokens or selected tokens added to the monitored tokens list.
 */
interface UpdateMonitoredTokensScopeInput {
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     */
    scope: TokenMonitorScope;
}
/**
 * Required parameters to create a new subscription.
 */
interface CreateSubscriptionInput {
    /**
     * URL of the endpoint to subscribe to notifications. Must be publicly accessible, use HTTPS, and respond with a 2XX status to a POST request.
     */
    endpoint: string;
}
/**
 * Represents the input to update a subscription .
 */
interface UpdateSubscriptionInput {
    /**
     * Subscription ID.
     */
    id: string;
    /**
     * Name of the subscription.
     */
    name: string;
    /**
     * Whether the subscription is enabled. `true` indicates the subscription is active.
     */
    enabled: boolean;
}

declare const getPublicKey: ({ configurationsClient }: APIParams) => () => Promise<TrimDataResponse<_shared_clients_configurations.PublicKey>>;

declare const createMonitoredTokens: ({ configurationsClient }: APIParams) => (input: CreateMonitoredTokensInput) => Promise<TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;

declare const deleteMonitoredTokens: ({ configurationsClient }: APIParams) => (input: DeleteMonitoredTokensInput) => Promise<axios.AxiosResponse<void, any, {}>>;

declare const listMonitoredTokens: ({ configurationsClient }: APIParams) => (input?: ListMonitoredTokensInput) => Promise<TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;

declare const updateMonitoredTokens: ({ configurationsClient }: APIParams) => (input: UpdateMonitoredTokensInput) => Promise<TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;

declare const updateMonitoredTokensScope: ({ configurationsClient, }: APIParams) => (input: UpdateMonitoredTokensScopeInput) => Promise<axios.AxiosResponse<void, any, {}>>;

declare const createSubscription: ({ configurationsClient }: APIParams) => (input: CreateSubscriptionInput) => Promise<TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;

declare const deleteSubscription: ({ configurationsClient }: APIParams) => (subscriptionId: string) => Promise<axios.AxiosResponse<void, any, {}>>;

declare const getSubscription: ({ configurationsClient }: APIParams) => (subscriptionId: string) => Promise<TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;

declare const getNotificationSignature: ({ configurationsClient, }: APIParams) => (subscriptionId: string) => Promise<TrimDataResponse<_shared_clients_configurations.NotificationSignaturePublicKey>>;

declare const listSubscriptions: ({ configurationsClient }: APIParams) => () => Promise<TrimDataResponse<_shared_clients_configurations.Subscriptions>>;

declare const updateSubscription: ({ configurationsClient }: APIParams) => ({ id, ...input }: UpdateSubscriptionInput) => Promise<TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;

/**
 * Utility function to sanitize the Axios response object by:
 * - removing the redundant 'data' property when calling the 'data' property again on the Axios response
 * - casting the headers to `Record<string, string>` for better type assertion.
 * @param response - The Axios response object.
 * @returns - The sanitized response object.
 */
declare const trimData: <T extends {
    data?: unknown;
}>(response: AxiosResponse<T>) => TrimDataResponse<T>;

/**
 * Resolves an absolute file path based on a relative path from the application's root directory.
 * @param relativePath - The relative path from the application's root directory.
 * @returns The absolute path resolved from the application's root directory.
 */
declare const resolvePathRelativeToAppDir: (relativePath: string) => string;

/**
 * Represents an in-memory storage implementation.
 */
declare class InMemoryStorage<TStoredData extends object> implements Storage<TStoredData> {
    private data;
    /**
     * Retrieves the value associated with the given key.
     * @param key - The key of the value to retrieve.
     * @returns A Promise that resolves to the value associated with the key, or undefined if the key doesn't exist.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets the value associated with the given key.
     * @param key - The key of the value to set.
     * @param value - The value to associate with the key. Use undefined to remove the key from the storage.
     * @returns A Promise that resolves once the value is set.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}

interface WithIdempotencyKey {
    /**
     * The optional idempotency key.
     * An idempotency key is a unique identifier used to identify and handle duplicate requests
     * in order to ensure idempotent behavior, where multiple identical requests have the same effect as a single request.
     *
     * We will generate one if you do not provide it.
     */
    idempotencyKey?: string;
}
type Cache = {
    /**
     * Public key of the entity.
     */
    publicKey: string;
};
type APIParamsWithEntitySecret<TStoredData extends Cache = Cache> = APIParams<unknown, TStoredData> & {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
};

/**
 * Method for securely encrypting an entity secret with a public key.
 * If the public key is not already stored, it fetches and stores it for future use.
 * @param params - Contains the entity secret and methods for managing storage.
 * @returns The encrypted entity secret, returned as a cipher text.
 */
declare const generateEntitySecretCiphertext: (params: APIParamsWithEntitySecret) => () => Promise<string>;

/**
 * Generates a unique idempotency key using the crypto library.
 * @returns A randomly generated idempotency key in UUID format.
 */
declare const generateIdempotencyKey: () => `${string}-${string}-${string}-${string}-${string}`;

/**
 * Represents the input parameters for requesting testnet tokens for your wallet.
 */
interface RequestTestnetTokensInput {
    /**
     * The address of the wallet that should receive the tokens.
     */
    address: string;
    /**
     * The blockchain the wallet that should receive the tokens is currently on.
     */
    blockchain: TestnetBlockchain;
    /**
     * Request native testnet tokens.
     */
    native?: boolean;
    /**
     * Request USDC testnet tokens.
     */
    usdc?: boolean;
    /**
     * Request EURC testnet tokens.
     */
    eurc?: boolean;
}
declare const requestTestnetTokens: ({ configurationsClient }: APIParams) => (input: RequestTestnetTokensInput) => Promise<axios.AxiosResponse<void, any, {}>>;

/**
 * Base class for all HTTP-related errors in the Circle Node SDK.
 * Provides common properties and functionality shared between HTTP response errors and HTTP request errors.
 * Replaces raw Axios errors to provide safe serialization and prevent sensitive data leakage.
 */
declare class HttpError<TCode extends string | number = string> extends Error {
    #private;
    static readonly code: string | number;
    static readonly message: string;
    code: TCode;
    message: string;
    url: string;
    method: string;
    constructor({ message, code, url, method, error, }: {
        message?: string | undefined;
        code?: TCode | undefined;
        url: string;
        method: string;
        error?: AxiosError | undefined;
    });
    get error(): AxiosError<unknown, any> | undefined;
}

/**
 * Base class for HTTP response errors (4xx, 5xx status codes).
 * Represents errors that occur after receiving an HTTP response from the server.
 * Provides safe serialization and prevents sensitive data leakage.
 */
declare class HttpResponseError extends HttpError<number> {
    static readonly code: number;
    static readonly message: string;
    status: number;
    constructor({ message, code, url, method, status, error, }: {
        message?: string | undefined;
        code?: number | undefined;
        url: string;
        method: string;
        status: number;
        error?: AxiosError | undefined;
    });
}

/**
 * Base class for errors that occur before receiving HTTP response.
 * Represents HTTP request errors - any error that happens before receiving the HTTP response.
 */
declare class HttpRequestError extends HttpError<string> {
    static readonly code: string;
    static readonly message: string;
}

/**
 * HTTP 400 Bad Request error.
 */
declare class BadRequestError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 401 Unauthorized error.
 */
declare class UnauthorizedError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 403 Forbidden error.
 */
declare class ForbiddenError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 404 Not Found error.
 */
declare class NotFoundError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 429 Rate Limit error.
 */
declare class RatelimitError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 500 Internal Server Error.
 */
declare class InternalServerError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 501 Not Implemented.
 */
declare class NotImplementedError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 502 Bad Gateway.
 */
declare class BadGatewayError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 503 Service Unavailable.
 */
declare class ServiceUnavailableError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * HTTP 504 Gateway Timeout.
 */
declare class GatewayTimeoutError extends HttpResponseError {
    static readonly code: number;
    static readonly message: string;
}

/**
 * Connection refused error (ECONNREFUSED).
 */
declare class ConnectionRefusedError extends HttpRequestError {
    static readonly code = "ECONNREFUSED";
    static readonly message: string;
}

/**
 * Connection timeout error (ETIMEDOUT).
 */
declare class ConnectionTimeoutError extends HttpRequestError {
    static readonly code = "ETIMEDOUT";
    static readonly message: string;
}

/**
 * Connection aborted error (ECONNABORTED) - typically request timeout.
 */
declare class ConnectionAbortedError extends HttpRequestError {
    static readonly code = "ECONNABORTED";
    static readonly message: string;
}

/**
 * DNS not found error (ENOTFOUND).
 */
declare class DNSNotFoundError extends HttpRequestError {
    static readonly code = "ENOTFOUND";
    static readonly message: string;
}

/**
 * DNS timeout error (EAI_AGAIN).
 */
declare class DNSTimeoutError extends HttpRequestError {
    static readonly code = "EAI_AGAIN";
    static readonly message: string;
}

/**
 * Network unreachable error (ENETUNREACH).
 */
declare class NetworkUnreachableError extends HttpRequestError {
    static readonly code = "ENETUNREACH";
    static readonly message: string;
}

/**
 * Connection reset error (ECONNRESET).
 */
declare class ConnectionResetError extends HttpRequestError {
    static readonly code = "ECONNRESET";
    static readonly message: string;
}

/**
 * Host unreachable error (EHOSTUNREACH).
 */
declare class HostUnreachableError extends HttpRequestError {
    static readonly code = "EHOSTUNREACH";
    static readonly message: string;
}

/**
 * Unified error parser for all Axios errors.
 * Automatically determines whether to create HttpResponseError or HttpRequestError
 * based on the presence of error.response.
 * @param error - The AxiosError to transform.
 * @returns Specific HttpError instance based on error type and status.
 */
declare function fromAxiosError(error: AxiosError): HttpResponseError | HttpRequestError;

/**
 * Circle API Error Classes
 * Hand-written error classes with codes and messages from errors.yaml.
 * REF for `code` and `message`: w3s-openapi-internal/openapi/components/errors.yaml.
 */

declare class Error110700 extends HttpResponseError {
    static readonly code = 110700;
    static readonly message = "The input amount is outside trade limit.";
}
declare class Error110701 extends HttpResponseError {
    static readonly code = 110701;
    static readonly message = "No quote is available with given input.";
}
declare class Error110702 extends HttpResponseError {
    static readonly code = 110702;
    static readonly message = "No supported configurations with given input.";
}
declare class Error110703 extends HttpResponseError {
    static readonly code = 110703;
    static readonly message = "refId already exists, should be unique.";
}
declare class Error155101 extends HttpResponseError {
    static readonly code = 155101;
    static readonly message = "Existing user already created with the provided userId.";
}
declare class Error155102 extends HttpResponseError {
    static readonly code = 155102;
    static readonly message = "Cannot find the user id in the system.";
}
declare class Error155103 extends HttpResponseError {
    static readonly code = 155103;
    static readonly message = "Cannot find the user token in the system.";
}
declare class Error155104 extends HttpResponseError {
    static readonly code = 155104;
    static readonly message = "The userToken had expired.";
}
declare class Error155105 extends HttpResponseError {
    static readonly code = 155105;
    static readonly message = "The userToken is invalid.";
}
declare class Error155106 extends HttpResponseError {
    static readonly code = 155106;
    static readonly message = "The user had already been initialized.";
}
declare class Error155107 extends HttpResponseError {
    static readonly code = 155107;
    static readonly message = "User has previously set a PIN. Use PUT /user/pin to reset the PIN.";
}
declare class Error155108 extends HttpResponseError {
    static readonly code = 155108;
    static readonly message = "User has previously set up their security questions, and they can't be reset.";
}
declare class Error155109 extends HttpResponseError {
    static readonly code = 155109;
    static readonly message = "The specified user has been disabled.";
}
declare class Error155110 extends HttpResponseError {
    static readonly code = 155110;
    static readonly message = "User has not set up a PIN yet.";
}
declare class Error155111 extends HttpResponseError {
    static readonly code = 155111;
    static readonly message = "User hasn't set the security questions for PIN backup yet.";
}
declare class Error155112 extends HttpResponseError {
    static readonly code = 155112;
    static readonly message = "The user has inputted the incorrect pin.";
}
declare class Error155113 extends HttpResponseError {
    static readonly code = 155113;
    static readonly message = "Provided device ID is not found in the system.";
}
declare class Error155114 extends HttpResponseError {
    static readonly code = 155114;
    static readonly message = "Provided app ID is not recognized in the system.";
}
declare class Error155115 extends HttpResponseError {
    static readonly code = 155115;
    static readonly message = "The user has inputted the incorrect security answers";
}
declare class Error155116 extends HttpResponseError {
    static readonly code = 155116;
    static readonly message = "The challenge ID doesn't exist in the system.";
}
declare class Error155117 extends HttpResponseError {
    static readonly code = 155117;
    static readonly message = "The content provided for approval is not correct.";
}
declare class Error155118 extends HttpResponseError {
    static readonly code = 155118;
    static readonly message = "Encryption key does not match with the user's token. Call POST /users/token to get the correct token encryption key pair.";
}
declare class Error155119 extends HttpResponseError {
    static readonly code = 155119;
    static readonly message = "The user's PIN input is locked. It will be unlocked after the cooldown period.";
}
declare class Error155120 extends HttpResponseError {
    static readonly code = 155120;
    static readonly message = "The user's security questions input is locked. It will be unlocked after the cooldown period.";
}
declare class Error155121 extends HttpResponseError {
    static readonly code = 155121;
    static readonly message = "The provided challengeId has expired.";
}
declare class Error155122 extends HttpResponseError {
    static readonly code = 155122;
    static readonly message = "The provided challengeId is invalid";
}
declare class Error155123 extends HttpResponseError {
    static readonly code = 155123;
    static readonly message = "No extra information provided when adding PIN-related requests.";
}
declare class Error155124 extends HttpResponseError {
    static readonly code = 155124;
    static readonly message = "The extra information provided for PIN-related requests is invalid.";
}
declare class Error155130 extends HttpResponseError {
    static readonly code = 155130;
    static readonly message = "User OTP token is expired.";
}
declare class Error155131 extends HttpResponseError {
    static readonly code = 155131;
    static readonly message = "User OTP token is invalid.";
}
declare class Error155132 extends HttpResponseError {
    static readonly code = 155132;
    static readonly message = "User OTP value is not found.";
}
declare class Error155133 extends HttpResponseError {
    static readonly code = 155133;
    static readonly message = "User OTP value is invalid.";
}
declare class Error155134 extends HttpResponseError {
    static readonly code = 155134;
    static readonly message = "User OTP value is not matched.";
}
declare class Error155135 extends HttpResponseError {
    static readonly code = 155135;
    static readonly message = "User's email is invalid.";
}
declare class Error155136 extends HttpResponseError {
    static readonly code = 155136;
    static readonly message = "User's email is not matched.";
}
declare class Error155137 extends HttpResponseError {
    static readonly code = 155137;
    static readonly message = "User's device ID is invalid.";
}
declare class Error155138 extends HttpResponseError {
    static readonly code = 155138;
    static readonly message = "Failed to send the email.";
}
declare class Error155139 extends HttpResponseError {
    static readonly code = 155139;
    static readonly message = "The idToken / accessToken of SSO is expired.";
}
declare class Error155140 extends HttpResponseError {
    static readonly code = 155140;
    static readonly message = "Failed to validate the idToken/ accessToken.";
}
declare class Error155141 extends HttpResponseError {
    static readonly code = 155141;
    static readonly message = "The user has exceeded the max limit (5) of entering OTP at the moment.";
}
declare class Error155142 extends HttpResponseError {
    static readonly code = 155142;
    static readonly message = "The max limit (5) of sending OTP has been exceeded at the moment.";
}
declare class Error155143 extends HttpResponseError {
    static readonly code = 155143;
    static readonly message = "The device token is expired.";
}
declare class Error155144 extends HttpResponseError {
    static readonly code = 155144;
    static readonly message = "The device token is invalid.";
}
declare class Error155145 extends HttpResponseError {
    static readonly code = 155145;
    static readonly message = "The device token is not found.";
}
declare class Error155146 extends HttpResponseError {
    static readonly code = 155146;
    static readonly message = "The one-time password token is invalid as the user has entered it incorrectly three times.";
}
declare class Error155150 extends HttpResponseError {
    static readonly code = 155150;
    static readonly message = "The SMTP server configuration is not found.";
}
declare class Error155151 extends HttpResponseError {
    static readonly code = 155151;
    static readonly message = "The SMTP server configuration is invalid.";
}
declare class Error155152 extends HttpResponseError {
    static readonly code = 155152;
    static readonly message = "The SSO provider configuration is not found.";
}
declare class Error155154 extends HttpResponseError {
    static readonly code = 155154;
    static readonly message = "The OTP email template is invalid.";
}
declare class Error155155 extends HttpResponseError {
    static readonly code = 155155;
    static readonly message = "The OTP email template is not found.";
}
declare class Error155156 extends HttpResponseError {
    static readonly code = 155156;
    static readonly message = "Failed to update the email template.";
}
declare class Error155157 extends HttpResponseError {
    static readonly code = 155157;
    static readonly message = "Failed to update the SMTP server configuration.";
}
declare class Error155158 extends HttpResponseError {
    static readonly code = 155158;
    static readonly message = "Failed to dial to the SMTP server.";
}
declare class Error155159 extends HttpResponseError {
    static readonly code = 155159;
    static readonly message = "Failed to auth to the SMTP server.";
}
declare class Error155160 extends HttpResponseError {
    static readonly code = 155160;
    static readonly message = "Failed to send to the SMTP server.";
}
declare class Error155201 extends HttpResponseError {
    static readonly code = 155201;
    static readonly message = "Not enough funds to fulfill the withdraw request.";
}
declare class Error155202 extends HttpResponseError {
    static readonly code = 155202;
    static readonly message = "Transaction nonce is inconsistent with sender's latest nonce.";
}
declare class Error155203 extends HttpResponseError {
    static readonly code = 155203;
    static readonly message = "User op nonce can not be larger than 0 when the smart contract wallet hasn't been deployed.";
}
declare class Error155204 extends HttpResponseError {
    static readonly code = 155204;
    static readonly message = "The total cost of executing transaction is higher than the balance of the user's account when estimating fee.";
}
declare class Error155205 extends HttpResponseError {
    static readonly code = 155205;
    static readonly message = "Failed to execute this request on EVM due to insufficient tokens when the estimating gas fee.";
}
declare class Error155206 extends HttpResponseError {
    static readonly code = 155206;
    static readonly message = "The sender address is not the token owner or the sender wasn't approved to commit this transaction.";
}
declare class Error155207 extends HttpResponseError {
    static readonly code = 155207;
    static readonly message = "Gas required exceeds the maximum allowance for the account. This is based on the gas fee estimate amount.";
}
declare class Error155208 extends HttpResponseError {
    static readonly code = 155208;
    static readonly message = "Estimate fee execution reverted.";
}
declare class Error155209 extends HttpResponseError {
    static readonly code = 155209;
    static readonly message = "ABI function signature can't pack ABI parameter.";
}
declare class Error155210 extends HttpResponseError {
    static readonly code = 155210;
    static readonly message = "Fails to perform transaction estimation.";
}
declare class Error155211 extends HttpResponseError {
    static readonly code = 155211;
    static readonly message = "MaxFee * GasLimit exceeded the maximum permitted transaction gas fee.";
}
declare class Error155215 extends HttpResponseError {
    static readonly code = 155215;
    static readonly message = "Unsupported operation for transaction.";
}
declare class Error155218 extends HttpResponseError {
    static readonly code = 155218;
    static readonly message = "Invalid number of nft in transaction request.";
}
declare class Error155219 extends HttpResponseError {
    static readonly code = 155219;
    static readonly message = "Invalid destination address.";
}
declare class Error155220 extends HttpResponseError {
    static readonly code = 155220;
    static readonly message = "Wallet and token's blockchain mismatch.";
}
declare class Error155221 extends HttpResponseError {
    static readonly code = 155221;
    static readonly message = "Invalid amounts in transfer request.";
}
declare class Error155222 extends HttpResponseError {
    static readonly code = 155222;
    static readonly message = "NFT metadata can not be found.";
}
declare class Error155223 extends HttpResponseError {
    static readonly code = 155223;
    static readonly message = "Unsupported userId for get transactions.";
}
declare class Error155224 extends HttpResponseError {
    static readonly code = 155224;
    static readonly message = "Failed to parse the provided amounts in request to decimals.";
}
declare class Error155225 extends HttpResponseError {
    static readonly code = 155225;
    static readonly message = "Wallet and request's blockchain mismatch.";
}
declare class Error155226 extends HttpResponseError {
    static readonly code = 155226;
    static readonly message = "Invalid source address.";
}
declare class Error155227 extends HttpResponseError {
    static readonly code = 155227;
    static readonly message = "Invalid transaction type.";
}
declare class Error155228 extends HttpResponseError {
    static readonly code = 155228;
    static readonly message = "Missing token ID.";
}
declare class Error155229 extends HttpResponseError {
    static readonly code = 155229;
    static readonly message = "Transaction is not eligible for operation.";
}
declare class Error155230 extends HttpResponseError {
    static readonly code = 155230;
    static readonly message = "No abi signature provided.";
}
declare class Error155231 extends HttpResponseError {
    static readonly code = 155231;
    static readonly message = "Transaction needs feeLevel or gasLimit provided.";
}
declare class Error155232 extends HttpResponseError {
    static readonly code = 155232;
    static readonly message = "SCA transaction needs feeLevel provided.";
}
declare class Error155233 extends HttpResponseError {
    static readonly code = 155233;
    static readonly message = "Provided gasLimit is too low to complete the requested transaction.";
}
declare class Error155234 extends HttpResponseError {
    static readonly code = 155234;
    static readonly message = "Transaction can't have both feeLevel and fee parameters provided.";
}
declare class Error155235 extends HttpResponseError {
    static readonly code = 155235;
    static readonly message = "EIP1559 chains need maxFee/priorityFee provided.";
}
declare class Error155236 extends HttpResponseError {
    static readonly code = 155236;
    static readonly message = "The provided fee in request is invalid.";
}
declare class Error155237 extends HttpResponseError {
    static readonly code = 155237;
    static readonly message = "PriorityFee cannot be larger than maxFee in creating transaction request.";
}
declare class Error155238 extends HttpResponseError {
    static readonly code = 155238;
    static readonly message = "Non-EIP1559 chains need gasPrice provided.";
}
declare class Error155239 extends HttpResponseError {
    static readonly code = 155239;
    static readonly message = "Invalid token address for transfer.";
}
declare class Error155240 extends HttpResponseError {
    static readonly code = 155240;
    static readonly message = "Invalid token standard for transfer.";
}
declare class Error155241 extends HttpResponseError {
    static readonly code = 155241;
    static readonly message = "Invalid token decimal for transfer.";
}
declare class Error155242 extends HttpResponseError {
    static readonly code = 155242;
    static readonly message = "The lengths of amounts and nft tokens don't match.";
}
declare class Error155243 extends HttpResponseError {
    static readonly code = 155243;
    static readonly message = "Missing bytecode for contract deployment.";
}
declare class Error155244 extends HttpResponseError {
    static readonly code = 155244;
    static readonly message = "Cannot provide both WalletID and SourceAddress/Blockchain.";
}
declare class Error155245 extends HttpResponseError {
    static readonly code = 155245;
    static readonly message = "Invalid amount in contract execution request.";
}
declare class Error155247 extends HttpResponseError {
    static readonly code = 155247;
    static readonly message = "Cannot provide both CallData and AbiFunctionSignature/AbiParameters.";
}
declare class Error155254 extends HttpResponseError {
    static readonly code = 155254;
    static readonly message = "Non-EIP1559 chains don't support maxFee/priorityFee.";
}
declare class Error155257 extends HttpResponseError {
    static readonly code = 155257;
    static readonly message = "the transfer amount is insufficient to make the destination account rent exempted or the balance of the source account is insufficient to remain rent exempted. The source address's remaining balance after transfer must be either zero or above the rent exemption threshold.";
}
declare class Error155258 extends HttpResponseError {
    static readonly code = 155258;
    static readonly message = "The asset amount owned by the wallet is insufficient for the transaction.";
}
declare class Error155262 extends HttpResponseError {
    static readonly code = 155262;
    static readonly message = "Account is not found, could be caused by transacting from a Solana account with zero balance.";
}
declare class Error155264 extends HttpResponseError {
    static readonly code = 155264;
    static readonly message = "Wait for pending transactions to be included on the blockchain before submitting new requests. EVM chains restrict the number of queued transactions per sender address.";
}
declare class Error155501 extends HttpResponseError {
    static readonly code = 155501;
    static readonly message = "Frozen wallets can not be updated or interact with, only query.";
}
declare class Error155502 extends HttpResponseError {
    static readonly code = 155502;
    static readonly message = "Max amount of wallets (tentative 1M) reached under 1 wallet set.";
}
declare class Error155503 extends HttpResponseError {
    static readonly code = 155503;
    static readonly message = "Metadata array length needs to match wallet count in create developer wallets request.";
}
declare class Error155504 extends HttpResponseError {
    static readonly code = 155504;
    static readonly message = "Metadata array length needs to match number of blockchains in create user wallets request.";
}
declare class Error155505 extends HttpResponseError {
    static readonly code = 155505;
    static readonly message = "SCA wallet needs to wait for first-time transaction to be queued before processing more transactions.";
}
declare class Error155506 extends HttpResponseError {
    static readonly code = 155506;
    static readonly message = "SCA wallet config is invalid.";
}
declare class Error155507 extends HttpResponseError {
    static readonly code = 155507;
    static readonly message = "SCA account is not supported on the given blockchain.";
}
declare class Error155508 extends HttpResponseError {
    static readonly code = 155508;
    static readonly message = "Can't create multiple user-controlled SCA wallets across multiple blockchains at a time.";
}
declare class Error155509 extends HttpResponseError {
    static readonly code = 155509;
    static readonly message = "Entity needs to setup paymaster policy in developer console before sending transaction on mainnet";
}
declare class Error155510 extends HttpResponseError {
    static readonly code = 155510;
    static readonly message = "The operation is not supported on the blockchain you specify.";
}
declare class Error155511 extends HttpResponseError {
    static readonly code = 155511;
    static readonly message = "Blockchain is not supported for wallet creation.";
}
declare class Error155512 extends HttpResponseError {
    static readonly code = 155512;
    static readonly message = "The owner of the SCA wallet can not be found.";
}
declare class Error155514 extends HttpResponseError {
    static readonly code = 155514;
    static readonly message = "circle_4337_v1 SCA wallet must be deployed before being upgraded.";
}
declare class Error155515 extends HttpResponseError {
    static readonly code = 155515;
    static readonly message = "The provided wallet account type is not supported by this API.";
}
declare class Error155516 extends HttpResponseError {
    static readonly code = 155516;
    static readonly message = "The source wallet was originally created on an SCA version that does not support wallet derivation.";
}
declare class Error155517 extends HttpResponseError {
    static readonly code = 155517;
    static readonly message = "The SCA wallet is not deployed onchain.";
}
declare class Error155601 extends HttpResponseError {
    static readonly code = 155601;
    static readonly message = "Failed to retrieve wallet set which already exists.";
}
declare class Error155701 extends HttpResponseError {
    static readonly code = 155701;
    static readonly message = "User canceled";
}
declare class Error155702 extends HttpResponseError {
    static readonly code = 155702;
    static readonly message = "<Launch UI failed reason>";
}
declare class Error155703 extends HttpResponseError {
    static readonly code = 155703;
    static readonly message = "The code you entered is not the same as the first one.";
}
declare class Error155704 extends HttpResponseError {
    static readonly code = 155704;
    static readonly message = "Your PIN can't have repeating or consecutive numbers.";
}
declare class Error155705 extends HttpResponseError {
    static readonly code = 155705;
    static readonly message = "Your hint can't be the same as the answer.";
}
declare class Error155706 extends HttpResponseError {
    static readonly code = 155706;
    static readonly message = "Network error";
}
declare class Error155707 extends HttpResponseError {
    static readonly code = 155707;
    static readonly message = "Failed to encrypt data";
}
declare class Error155708 extends HttpResponseError {
    static readonly code = 155708;
    static readonly message = "\"Biometrics instead of PIN\" is disabled";
}
declare class Error155709 extends HttpResponseError {
    static readonly code = 155709;
    static readonly message = "The device system doesn't support biometrics";
}
declare class Error155710 extends HttpResponseError {
    static readonly code = 155710;
    static readonly message = "Failed to decrypt biometrics key";
}
declare class Error155711 extends HttpResponseError {
    static readonly code = 155711;
    static readonly message = "The user has not enabled biometrics yet";
}
declare class Error155712 extends HttpResponseError {
    static readonly code = 155712;
    static readonly message = "The user refused to enable biometrics";
}
declare class Error155713 extends HttpResponseError {
    static readonly code = 155713;
    static readonly message = "Too many requests. Try again later";
}
declare class Error155714 extends HttpResponseError {
    static readonly code = 155714;
    static readonly message = "Too many requests. The biometrics sensor on the device is locked.";
}
declare class Error155715 extends HttpResponseError {
    static readonly code = 155715;
    static readonly message = "The user didn't enable biometrics";
}
declare class Error155716 extends HttpResponseError {
    static readonly code = 155716;
    static readonly message = "Unexpected error for biometrics";
}
declare class Error155717 extends HttpResponseError {
    static readonly code = 155717;
    static readonly message = "User secret is missing.";
}
declare class Error155718 extends HttpResponseError {
    static readonly code = 155718;
    static readonly message = "User secret is invalid.";
}
declare class Error155719 extends HttpResponseError {
    static readonly code = 155719;
    static readonly message = "User token and SDK API execute function does not match.";
}
declare class Error155720 extends HttpResponseError {
    static readonly code = 155720;
    static readonly message = "Social login failed.";
}
declare class Error155721 extends HttpResponseError {
    static readonly code = 155721;
    static readonly message = "Login info is missing.";
}
declare class Error155801 extends HttpResponseError {
    static readonly code = 155801;
    static readonly message = "Transaction or rawTransaction is invalid.";
}
declare class Error155802 extends HttpResponseError {
    static readonly code = 155802;
    static readonly message = "Account not found.";
}
declare class Error155803 extends HttpResponseError {
    static readonly code = 155803;
    static readonly message = "Not signer account.";
}
declare class Error155804 extends HttpResponseError {
    static readonly code = 155804;
    static readonly message = "Transaction already signed.";
}
declare class Error155805 extends HttpResponseError {
    static readonly code = 155805;
    static readonly message = "Transaction failed to deserialize.";
}
declare class Error155806 extends HttpResponseError {
    static readonly code = 155806;
    static readonly message = "The transaction size exceeds blockchain limit.";
}
declare class Error155807 extends HttpResponseError {
    static readonly code = 155807;
    static readonly message = "The chain ID is not supported for signing.";
}
declare class Error155808 extends HttpResponseError {
    static readonly code = 155808;
    static readonly message = "The chain ID is missing in sign request.";
}
declare class Error156001 extends HttpResponseError {
    static readonly code = 156001;
    static readonly message = "Cannot find target wallet in the system. Either the specified wallet doesn't exist or it's not accessible to the caller.";
}
declare class Error156002 extends HttpResponseError {
    static readonly code = 156002;
    static readonly message = "Cannot find target token in the system. Either the specified token doesn't exist or it's not accessible to the caller.";
}
declare class Error156003 extends HttpResponseError {
    static readonly code = 156003;
    static readonly message = "Cannot find target transaction in the system. Either the specified transaction doesn't exist or it's not accessible to the caller.";
}
declare class Error156004 extends HttpResponseError {
    static readonly code = 156004;
    static readonly message = "Reusing an entity secret ciphertext is not allowed. Please re-encrypt the entity secret to generate new ciphertext.";
}
declare class Error156005 extends HttpResponseError {
    static readonly code = 156005;
    static readonly message = "Cannot find target wallet set in the system. Either no such wallet set, or it's not accessible to the caller.";
}
declare class Error156006 extends HttpResponseError {
    static readonly code = 156006;
    static readonly message = "TEST_API key cannot be used with blockchain mainnets, or LIVE_API key cannot be used with blockchain testnets.";
}
declare class Error156007 extends HttpResponseError {
    static readonly code = 156007;
    static readonly message = "TEST_API key or LIVE_API key is not found for the request.";
}
declare class Error156008 extends HttpResponseError {
    static readonly code = 156008;
    static readonly message = "Cannot find target entity config in the system. Either no such entity config, or it's not accessible to the caller.";
}
declare class Error156009 extends HttpResponseError {
    static readonly code = 156009;
    static readonly message = "Fail to parse id as UUID in url.";
}
declare class Error156010 extends HttpResponseError {
    static readonly code = 156010;
    static readonly message = "Cannot find the corresponding entity in the system.";
}
declare class Error156011 extends HttpResponseError {
    static readonly code = 156011;
    static readonly message = "Cannot find target nftTokenId in the system.";
}
declare class Error156012 extends HttpResponseError {
    static readonly code = 156012;
    static readonly message = "Cannot find corresponding pagination cursor in the system.";
}
declare class Error156013 extends HttpResponseError {
    static readonly code = 156013;
    static readonly message = "The provided entity secret is invalid.";
}
declare class Error156014 extends HttpResponseError {
    static readonly code = 156014;
    static readonly message = "Pagination params are invalid. Only UUID format is supported for pageBefore and pageAfter.";
}
declare class Error156015 extends HttpResponseError {
    static readonly code = 156015;
    static readonly message = "The secret for this entity has already been set.";
}
declare class Error156016 extends HttpResponseError {
    static readonly code = 156016;
    static readonly message = "The entity secret has not been set yet. Please provide encrypted ciphertext in the console.";
}
declare class Error156017 extends HttpResponseError {
    static readonly code = 156017;
    static readonly message = "The specified blockchain parameters are incorrect.";
}
declare class Error156018 extends HttpResponseError {
    static readonly code = 156018;
    static readonly message = "The uploaded recovery file is invalid.";
}
declare class Error156019 extends HttpResponseError {
    static readonly code = 156019;
    static readonly message = "Current entity secret is invalid. Please rotate the entity secret first.";
}
declare class Error156020 extends HttpResponseError {
    static readonly code = 156020;
    static readonly message = "Please use a new idempotency key.";
}
declare class Error156021 extends HttpResponseError {
    static readonly code = 156021;
    static readonly message = "A new wallet set ID is required.";
}
declare class Error156023 extends HttpResponseError {
    static readonly code = 156023;
    static readonly message = "EncodedByHex is true in sign request, but the message is not hex encoded.";
}
declare class Error156024 extends HttpResponseError {
    static readonly code = 156024;
    static readonly message = "Data is not a valid JSON string in sign request.";
}
declare class Error156025 extends HttpResponseError {
    static readonly code = 156025;
    static readonly message = "Invalid message in request.";
}
declare class Error156026 extends HttpResponseError {
    static readonly code = 156026;
    static readonly message = "Invalid typed data in request.";
}
declare class Error156027 extends HttpResponseError {
    static readonly code = 156027;
    static readonly message = "The specified blockchain is either not supported or deprecated.";
}
declare class Error156030 extends HttpResponseError {
    static readonly code = 156030;
    static readonly message = "Invalid unsigned delegate action in request.";
}
declare class Error156031 extends HttpResponseError {
    static readonly code = 156031;
    static readonly message = "The specified token address is not supported.";
}
declare class Error156032 extends HttpResponseError {
    static readonly code = 156032;
    static readonly message = "The provided amount is invalid.";
}
declare class Error175001 extends HttpResponseError {
    static readonly code = 175001;
    static readonly message = "contract not found";
}
declare class Error175002 extends HttpResponseError {
    static readonly code = 175002;
    static readonly message = "no ABI JSON for the target contract";
}
declare class Error175003 extends HttpResponseError {
    static readonly code = 175003;
    static readonly message = "constructor parameters length must match constructor signature";
}
declare class Error175004 extends HttpResponseError {
    static readonly code = 175004;
    static readonly message = "contract already exists";
}
declare class Error175005 extends HttpResponseError {
    static readonly code = 175005;
    static readonly message = "address is not a contract address";
}
declare class Error175006 extends HttpResponseError {
    static readonly code = 175006;
    static readonly message = "contract is archived";
}
declare class Error175007 extends HttpResponseError {
    static readonly code = 175007;
    static readonly message = "invalid ABI JSON";
}
declare class Error175008 extends HttpResponseError {
    static readonly code = 175008;
    static readonly message = "multi-layered proxies are not supported";
}
declare class Error175009 extends HttpResponseError {
    static readonly code = 175009;
    static readonly message = "contract deployment pending";
}
declare class Error175010 extends HttpResponseError {
    static readonly code = 175010;
    static readonly message = "ABI function not found";
}
declare class Error175011 extends HttpResponseError {
    static readonly code = 175011;
    static readonly message = "empty update on a contract";
}
declare class Error175012 extends HttpResponseError {
    static readonly code = 175012;
    static readonly message = "unable to query contract";
}
declare class Error175013 extends HttpResponseError {
    static readonly code = 175013;
    static readonly message = "ABI function is not supported";
}
declare class Error175201 extends HttpResponseError {
    static readonly code = 175201;
    static readonly message = "template not found";
}
declare class Error175202 extends HttpResponseError {
    static readonly code = 175202;
    static readonly message = "deploying this template is temporarily disabled";
}
declare class Error175203 extends HttpResponseError {
    static readonly code = 175203;
    static readonly message = "invalid template deployment parameter";
}
declare class Error175204 extends HttpResponseError {
    static readonly code = 175204;
    static readonly message = "missing required template deployment parameter";
}
declare class Error175205 extends HttpResponseError {
    static readonly code = 175205;
    static readonly message = "estimation is not supported";
}
declare class Error175301 extends HttpResponseError {
    static readonly code = 175301;
    static readonly message = "event subscription not found";
}
declare class Error175302 extends HttpResponseError {
    static readonly code = 175302;
    static readonly message = "event subscription already exists";
}
declare class Error175303 extends HttpResponseError {
    static readonly code = 175303;
    static readonly message = "the specified event signature does not exist";
}
declare class Error175401 extends HttpResponseError {
    static readonly code = 175401;
    static readonly message = "failed to parse id as UUID in url";
}
declare class Error175402 extends HttpResponseError {
    static readonly code = 175402;
    static readonly message = "the specified blockchain is either not supported or deprecated";
}
declare class Error175403 extends HttpResponseError {
    static readonly code = 175403;
    static readonly message = "please use a new idempotency key";
}
declare class Error175404 extends HttpResponseError {
    static readonly code = 175404;
    static readonly message = "TEST_API key cannot be used with blockchain mainnets, or LIVE_API key cannot be used with blockchain testnets";
}
declare class Error175405 extends HttpResponseError {
    static readonly code = 175405;
    static readonly message = "TEST_API key or LIVE_API key is not found for the request";
}
declare class Error175406 extends HttpResponseError {
    static readonly code = 175406;
    static readonly message = "this feature is temporarily disabled";
}
declare class Error175407 extends HttpResponseError {
    static readonly code = 175407;
    static readonly message = "the specified blockchain is currently unavailable";
}
declare class Error175408 extends HttpResponseError {
    static readonly code = 175408;
    static readonly message = "can not find corresponding pagination cursor in the system";
}
declare class Error175409 extends HttpResponseError {
    static readonly code = 175409;
    static readonly message = "restricted entity cannot perform this operation";
}
declare class Error175410 extends HttpResponseError {
    static readonly code = 175410;
    static readonly message = "invalid address format";
}
declare class Error177001 extends HttpResponseError {
    static readonly code = 177001;
    static readonly message = "transaction nonce is inconsistent with sender's latest nonce";
}
declare class Error177002 extends HttpResponseError {
    static readonly code = 177002;
    static readonly message = "user op nonce can not be larger than 0 when smart contract wallet hasn't been deployed";
}
declare class Error177003 extends HttpResponseError {
    static readonly code = 177003;
    static readonly message = "failed to execute this request on EVM due to insufficient token when estimating fee";
}
declare class Error177004 extends HttpResponseError {
    static readonly code = 177004;
    static readonly message = "the total cost of executing transaction is higher than the balance of the user's account when estimating fee";
}
declare class Error177005 extends HttpResponseError {
    static readonly code = 177005;
    static readonly message = "the sender address is not token owner or approved when estimating token transfer";
}
declare class Error177006 extends HttpResponseError {
    static readonly code = 177006;
    static readonly message = "gas required exceeds allowance when estimating fee";
}
declare class Error177007 extends HttpResponseError {
    static readonly code = 177007;
    static readonly message = "estimate fee execution reverted";
}
declare class Error177008 extends HttpResponseError {
    static readonly code = 177008;
    static readonly message = "ABI function signature can't pack ABI parameter";
}
declare class Error177009 extends HttpResponseError {
    static readonly code = 177009;
    static readonly message = "fails to perform transaction estimation";
}
declare class Error177010 extends HttpResponseError {
    static readonly code = 177010;
    static readonly message = "MaxFee * GasLimit exceeds configurable max transaction fee (default is 1 native token)";
}
declare class Error177011 extends HttpResponseError {
    static readonly code = 177011;
    static readonly message = "transaction needs feeLevel or gasLimit provided";
}
declare class Error177012 extends HttpResponseError {
    static readonly code = 177012;
    static readonly message = "SCA transaction needs feeLevel provided";
}
declare class Error177013 extends HttpResponseError {
    static readonly code = 177013;
    static readonly message = "EIP1559 chains need maxFee/priorityFee provided";
}
declare class Error177014 extends HttpResponseError {
    static readonly code = 177014;
    static readonly message = "priorityFee cannot be larger than maxFee in creating transaction request";
}
declare class Error177015 extends HttpResponseError {
    static readonly code = 177015;
    static readonly message = "missing bytecode for contract deployment";
}
declare class Error177016 extends HttpResponseError {
    static readonly code = 177016;
    static readonly message = "cannot provide both WalletID and SourceAddress/Blockchain";
}
declare class Error177017 extends HttpResponseError {
    static readonly code = 177017;
    static readonly message = "invalid amount in contract execution request";
}
declare class Error177018 extends HttpResponseError {
    static readonly code = 177018;
    static readonly message = "policy is not activated and cannot be used";
}
declare class Error177019 extends HttpResponseError {
    static readonly code = 177019;
    static readonly message = "exceeded max daily transaction of the policy";
}
declare class Error177020 extends HttpResponseError {
    static readonly code = 177020;
    static readonly message = "exceeded max spend USD per transaction of the policy";
}
declare class Error177021 extends HttpResponseError {
    static readonly code = 177021;
    static readonly message = "exceeded max spend USD daily of the policy";
}
declare class Error177022 extends HttpResponseError {
    static readonly code = 177022;
    static readonly message = "exceeded max native token daily of the policy";
}
declare class Error177023 extends HttpResponseError {
    static readonly code = 177023;
    static readonly message = "sender is in policy blocklist";
}
declare class Error177024 extends HttpResponseError {
    static readonly code = 177024;
    static readonly message = "Wallet and request's blockchain mismatch.";
}
declare class Error177025 extends HttpResponseError {
    static readonly code = 177025;
    static readonly message = "the asset amount owned by the wallet is insufficient for the transaction";
}
declare class Error177026 extends HttpResponseError {
    static readonly code = 177026;
    static readonly message = "Wait for pending transactions to be included on the blockchain before submitting new requests. EVM chains restrict the number of queued transactions per sender address.";
}
declare class Error177301 extends HttpResponseError {
    static readonly code = 177301;
    static readonly message = "wallet is Frozen";
}
declare class Error177302 extends HttpResponseError {
    static readonly code = 177302;
    static readonly message = "invalid sca wallet config";
}
declare class Error177303 extends HttpResponseError {
    static readonly code = 177303;
    static readonly message = "SCA wallet first-time transaction is still in progress";
}
declare class Error177304 extends HttpResponseError {
    static readonly code = 177304;
    static readonly message = "SCA account is not supported on the given blockchain";
}
declare class Error177305 extends HttpResponseError {
    static readonly code = 177305;
    static readonly message = "entity is not eligible for SCA account creation. Please check paymaster policy setup";
}
declare class Error177601 extends HttpResponseError {
    static readonly code = 177601;
    static readonly message = "cannot find target wallet in the system. Either the specified wallet doesn't exist or it's not accessible to the caller";
}
declare class Error177602 extends HttpResponseError {
    static readonly code = 177602;
    static readonly message = "reusing an entity secret ciphertext is not allowed. Please re-encrypt the entity secret to generate new ciphertext";
}
declare class Error177603 extends HttpResponseError {
    static readonly code = 177603;
    static readonly message = "cannot find the corresponding entity in the system";
}
declare class Error177604 extends HttpResponseError {
    static readonly code = 177604;
    static readonly message = "the provided entity secret is invalid";
}
declare class Error177605 extends HttpResponseError {
    static readonly code = 177605;
    static readonly message = "the entity secret has not been set yet. Please provide encrypted ciphertext in the console";
}
declare class Error177606 extends HttpResponseError {
    static readonly code = 177606;
    static readonly message = "current entity secret is invalid. Please rotate the entity secret first";
}
declare class Error177607 extends HttpResponseError {
    static readonly code = 177607;
    static readonly message = "please use a new idempotency key";
}
declare class Error177901 extends HttpResponseError {
    static readonly code = 177901;
    static readonly message = "smart contract query failed";
}

export { type APIParams, type APIReturnType, BadGatewayError, BadRequestError, type ClientParams, type Common, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError, ConnectionTimeoutError, type CreateMonitoredTokensInput, type CreateSubscriptionInput, DNSNotFoundError, DNSTimeoutError, type DeleteMonitoredTokensInput, Error110700, Error110701, Error110702, Error110703, Error155101, Error155102, Error155103, Error155104, Error155105, Error155106, Error155107, Error155108, Error155109, Error155110, Error155111, Error155112, Error155113, Error155114, Error155115, Error155116, Error155117, Error155118, Error155119, Error155120, Error155121, Error155122, Error155123, Error155124, Error155130, Error155131, Error155132, Error155133, Error155134, Error155135, Error155136, Error155137, Error155138, Error155139, Error155140, Error155141, Error155142, Error155143, Error155144, Error155145, Error155146, Error155150, Error155151, Error155152, Error155154, Error155155, Error155156, Error155157, Error155158, Error155159, Error155160, Error155201, Error155202, Error155203, Error155204, Error155205, Error155206, Error155207, Error155208, Error155209, Error155210, Error155211, Error155215, Error155218, Error155219, Error155220, Error155221, Error155222, Error155223, Error155224, Error155225, Error155226, Error155227, Error155228, Error155229, Error155230, Error155231, Error155232, Error155233, Error155234, Error155235, Error155236, Error155237, Error155238, Error155239, Error155240, Error155241, Error155242, Error155243, Error155244, Error155245, Error155247, Error155254, Error155257, Error155258, Error155262, Error155264, Error155501, Error155502, Error155503, Error155504, Error155505, Error155506, Error155507, Error155508, Error155509, Error155510, Error155511, Error155512, Error155514, Error155515, Error155516, Error155517, Error155601, Error155701, Error155702, Error155703, Error155704, Error155705, Error155706, Error155707, Error155708, Error155709, Error155710, Error155711, Error155712, Error155713, Error155714, Error155715, Error155716, Error155717, Error155718, Error155719, Error155720, Error155721, Error155801, Error155802, Error155803, Error155804, Error155805, Error155806, Error155807, Error155808, Error156001, Error156002, Error156003, Error156004, Error156005, Error156006, Error156007, Error156008, Error156009, Error156010, Error156011, Error156012, Error156013, Error156014, Error156015, Error156016, Error156017, Error156018, Error156019, Error156020, Error156021, Error156023, Error156024, Error156025, Error156026, Error156027, Error156030, Error156031, Error156032, Error175001, Error175002, Error175003, Error175004, Error175005, Error175006, Error175007, Error175008, Error175009, Error175010, Error175011, Error175012, Error175013, Error175201, Error175202, Error175203, Error175204, Error175205, Error175301, Error175302, Error175303, Error175401, Error175402, Error175403, Error175404, Error175405, Error175406, Error175407, Error175408, Error175409, Error175410, Error177001, Error177002, Error177003, Error177004, Error177005, Error177006, Error177007, Error177008, Error177009, Error177010, Error177011, Error177012, Error177013, Error177014, Error177015, Error177016, Error177017, Error177018, Error177019, Error177020, Error177021, Error177022, Error177023, Error177024, Error177025, Error177026, Error177301, Error177302, Error177303, Error177304, Error177305, Error177601, Error177602, Error177603, Error177604, Error177605, Error177606, Error177607, Error177901, type FeeConfiguration, ForbiddenError, GatewayTimeoutError, HostUnreachableError, HttpError, HttpRequestError, HttpResponseError, InMemoryStorage, InternalServerError, type ListMonitoredTokensInput, NetworkUnreachableError, NotFoundError, NotImplementedError, type Pagination, RatelimitError, type RequestTestnetTokensInput, ServiceUnavailableError, type Storage, type TrimDataResponse, UnauthorizedError, type UpdateMonitoredTokensInput, type UpdateMonitoredTokensScopeInput, type UpdateSubscriptionInput, type WithIdempotencyKey, createMonitoredTokens, createSubscription, deleteMonitoredTokens, deleteSubscription, fromAxiosError, generateEntitySecretCiphertext, generateIdempotencyKey, getNotificationSignature, getPublicKey, getSubscription, listMonitoredTokens, listSubscriptions, requestTestnetTokens, resolvePathRelativeToAppDir, trimData, updateMonitoredTokens, updateMonitoredTokensScope, updateSubscription };
